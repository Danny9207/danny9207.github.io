[{"title":"java并发-java中的锁","date":"2018-09-19T12:32:25.000Z","path":"2018/09/19/java-concurrent-three/","text":"java中的锁围绕两个方面：“使用”，“实现”。 1. Lock接口Lock接口提供了synchronized所不具备的特性： 特性 描述 尝试非阻塞地获取锁 当线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取到锁。 能被中断的获取锁 与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断，中断异常会被抛出，同时锁会被释放。 超时获取锁 在指定的时间内获取锁，如果时间到了仍无法获取锁，则返回。 2. 队列同步器（QAS）AbstractQueuedSynchronizer是用来构建锁或其他同步组件的基础框架，它使用一个int成员变量表示同步状态；通过内置的FIFO队列来完成资源获取线程的排队工作。 使用 自定义同步组件（CustomLock）需要聚合一个AQS的子类（SpecificSynchronizer）。SpecificSynchronizer可重写的方法： 方法名称 描述 protected boolean tryAcquire (int arg) 独占式获取同步状态。实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行 CAS 设置同步状态。 protected boolean tryRelease (int arg) 独占式释放同步状态。等待获取同步状态的线程将有机会获取同步状态。 protected int tryAcquireShared (int arg) 共享式获取同步状态。返回大于等于0的值，表示获取成功，反之获取失败。 protected boolean tryReleaseShared (int arg) 共享式释放同步状态。 protected boolean isHeldExclusively() 当前同步器是否在独占模式卜被线程占用，一般该方法表示是否被当前线程所独占。 CustomLock可调用的SpecificSynchronizer提供的部分模板方法如下： 方法名称 描述 void acquire (int arg) 独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire(int arg)方法。 void acquireInterruptibly (int arg) 与acquire (int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进人同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回。 boolean tryAcquireNanos (int arg, long nanos) 在acquireInterruptibly (int arg)的基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true。 void acquireShared(int arg) 共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态。 void acquireSharedInterruptibly(int arg) 与acquireShared(int arg)相同，该方法响应中断。 boolean tryAcquireSharedNanos(int arg, long nanos) 与acquireSharedInterruptibly(int arg)基础上增加了超时等待限制。 boolean release(int arg) 独占式释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒。 boolean releaseShared(int arg) 共享式的释放同步状态。 Collection getQueuedThreads() 获取等待在同步队列上的线程集合。 实现；独占式获取同步状态的关键点： AQS依赖内部的同步队列（一个FIFO的双向队列）来完成同步状态的管理。同步队列中节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱节点和后继节点。 通过调用AQS的acquire(int arg)方法可以获取同步状态。 首先调用SpecificSynchronizer实现的tryAcquire(int arg)，该方法保证线程安全的获取同步状态。 如果获取同步状态失败，通过调用addWaiter(Node node)方法将该节点加入到同步队列的尾部。主要是有一段快速尝试在尾部添加节点的操作。 在enq(final Node node)方法中，主要是通过CAS将节点正确地设置成尾节点。 节点加入同步队列后，调用acquireQueued(final Node node, int arg)方法进入一个自旋的过程。每个节点（或者说每个线程）都在自省的观察；当条件满足，获取到了同步状态，就会从自旋过程中退出；否则依旧停留在自旋过程中。 acquireQueued(final Node node, int arg)的主要操作有两个：一是判断是否当前节点的前驱节点是head节点，并且成功获取到了同步状态；则将当前节点设置为head节点，并将前驱节点设置为null。最后是返回并退出自旋，继续执行线程任务。二是根据当前节点的前驱节点的waitStatus是否是SIGNAL来决定是否park当前节点中的线程。这里有一段将前驱节点的waitStatus设置为SIGNAL的操作，所以同步队列中的任意节点的前驱节点的waitStatus为SIGNAL，则任意节点中的线程就会park。 release(int arg)的作用是调用tryRelease(int arg)将state设置为0，如果成功则唤醒（unpark）在队列自旋中park的，并且是head节点的后继节点中的线程。 参考测试代码： https://github.com/legend9207/concurrent_code/blob/master/src/com/roocon/thread/ta4/Main.java 3. 重入锁4. 读写锁","tags":[]},{"title":"java并发-并发编程基础","date":"2018-09-13T13:29:13.000Z","path":"2018/09/13/java-concurrent-two/","text":"java并发编程基础1. 线程简介线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。 线程状态：NEW：初始状态，线程被构建，但是还没有调用start()方法。RUNNABLE：运行状态，java将操作系统中的“就绪”和“运行”两种状态统称为“运行中”。此时处于Thread.start()方法调用之后。处于WAITING，TIME_WAITING状态的线程在调用Object.notify()，Object.notifyAll()，LockSupport.unpark(Thread)方法之后，也会进入RUNNABLE状态。BLOCKED：阻塞状态，表示线程阻塞于锁。此时线程等待进入synchronized代码块或方法。获取到锁后进入RUNNABLE状态。WAITING：等待状态，进入该状态表示当前线程需要其他线程做出一些特定的动作（通知或中断），此时处于Object.wait()，Object.join()或LockSupport.park()方法调用之后。TIME_WAITING：超时等待状态，它与WAITING不同，它可以在指定的时间自行返回。此时处于Thread.sleep(long)，Object.wait(long)，Thread.join(long)，LockSupport.parkNanos()，LockSupport.parkUntil()方法调用之后。TERMINATED：终止状态，表示线程已经执行完毕。 2. 启动和终止线程待完成 3. 线程间通信等待通知范式 等待方遵循的原则： “线程”获取对象的锁。 如果条件不满足则调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑。代码：123456synchronized(对象) &#123; while(条件不满足) &#123; 对象.wait(); &#125; 处理对应的逻辑&#125; 通知方遵循的原则： “线程”获取对象的锁。 改变条件。 通知所有等待在对象上的线程。代码：1234synchronized(对象)&#123; 改变条件 对象.notifyAll();&#125; Thread.join的原理解释：1234//场景：main() &#123; thread.join();&#125; 123456789101112//解释：// 加锁当前线程对象。//此时的“对象”锁是thread。相当于范式中的“synchronized(对象)”public final synchronized void join() throws InterruptedException &#123; // 条件不满足，继续等待 while (isAlive()) &#123; //thread调用自身的wait方法。 //相当于范式中“对象.wait()”。所以此时等待的是“main线程&apos;对象&apos;”。 wait(0); &#125; // 条件符合，方法返回&#125; 4. 线程应用实例","tags":[]},{"title":"java并发-java内存模型","date":"2018-09-03T13:33:54.000Z","path":"2018/09/03/java-concurrent-one/","text":"java内存模型1. 内存模型JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个私有的本地内存，本地内存存储了该线程用来读/写共享变量的副本。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序提供内存可见性的保证。 2. volatile&emsp;&emsp;特性 可见性。对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。 原子性。对于单个volatile变量的读写具有原子性，但类似于volatile++的复合操作不具有原子性。 &emsp;&emsp;写-读的内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 当读一个volatile变量时，JMM会把该行程对应的本地内存的值置为无效，线程接下来将从主内存中读取共享变量。 &emsp;&emsp;内存语义实现原理为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的JMM内存屏障插入策略： 在每一个volatile写操作的前面插入一个StoreStore屏障。 在每一个volatile写操作的后面插入一个StoreLoad屏障。 在每一个volatile读操作的后面插入一个LoadLoad屏障。 在每一个volatile读操作的后面插入一个LoadStore屏障。 3. synchronized&emsp;&emsp;特性锁可以让临界区互斥执行。 &emsp;&emsp;释放-获取的内存语义 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使线程中的代码必须从主内存中读取共享变量。 &emsp;&emsp;内存语义实现原理 利用volatile变量的读-写所具有的的内存语义。 利用CAS所附带的volatile读和volatile写的内存语义。 4. final待完成 :sleeping:","tags":[]},{"title":"Hello World","date":"2018-07-21T08:36:43.995Z","path":"2018/07/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]